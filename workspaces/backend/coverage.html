
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kubeflow/notebooks/workspaces/backend/api/app.go (12.5%)</option>
				
				<option value="file1">github.com/kubeflow/notebooks/workspaces/backend/api/auth.go (44.0%)</option>
				
				<option value="file2">github.com/kubeflow/notebooks/workspaces/backend/api/healthcheck_handler.go (57.1%)</option>
				
				<option value="file3">github.com/kubeflow/notebooks/workspaces/backend/api/helpers.go (68.8%)</option>
				
				<option value="file4">github.com/kubeflow/notebooks/workspaces/backend/api/logging.go (0.0%)</option>
				
				<option value="file5">github.com/kubeflow/notebooks/workspaces/backend/api/middleware.go (0.0%)</option>
				
				<option value="file6">github.com/kubeflow/notebooks/workspaces/backend/api/namespaces_handler.go (66.7%)</option>
				
				<option value="file7">github.com/kubeflow/notebooks/workspaces/backend/api/response_errors.go (16.7%)</option>
				
				<option value="file8">github.com/kubeflow/notebooks/workspaces/backend/api/response_success.go (75.0%)</option>
				
				<option value="file9">github.com/kubeflow/notebooks/workspaces/backend/api/swagger_handler.go (0.0%)</option>
				
				<option value="file10">github.com/kubeflow/notebooks/workspaces/backend/api/workspacekinds_handler.go (70.4%)</option>
				
				<option value="file11">github.com/kubeflow/notebooks/workspaces/backend/api/workspaces_handler.go (61.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "log/slog"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apiserver/pkg/authentication/authenticator"
        "k8s.io/apiserver/pkg/authorization/authorizer"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/kubeflow/notebooks/workspaces/backend/internal/config"
        "github.com/kubeflow/notebooks/workspaces/backend/internal/repositories"
        _ "github.com/kubeflow/notebooks/workspaces/backend/openapi"
)

const (
        Version    = "1.0.0"
        PathPrefix = "/api/v1"

        NamespacePathParam    = "namespace"
        ResourceNamePathParam = "name"

        // healthcheck
        HealthCheckPath = PathPrefix + "/healthcheck"

        // workspaces
        AllWorkspacesPath         = PathPrefix + "/workspaces"
        WorkspacesByNamespacePath = AllWorkspacesPath + "/:" + NamespacePathParam
        WorkspacesByNamePath      = AllWorkspacesPath + "/:" + NamespacePathParam + "/:" + ResourceNamePathParam

        // workspacekinds
        AllWorkspaceKindsPath    = PathPrefix + "/workspacekinds"
        WorkspaceKindsByNamePath = AllWorkspaceKindsPath + "/:" + ResourceNamePathParam

        // namespaces
        AllNamespacesPath = PathPrefix + "/namespaces"

        // swagger
        SwaggerPath    = PathPrefix + "/swagger/*any"
        SwaggerDocPath = PathPrefix + "/swagger/doc.json"
)

type App struct {
        Config       *config.EnvConfig
        logger       *slog.Logger
        repositories *repositories.Repositories
        Scheme       *runtime.Scheme
        RequestAuthN authenticator.Request
        RequestAuthZ authorizer.Authorizer
}

// NewApp creates a new instance of the app
func NewApp(cfg *config.EnvConfig, logger *slog.Logger, cl client.Client, scheme *runtime.Scheme, reqAuthN authenticator.Request, reqAuthZ authorizer.Authorizer) (*App, error) <span class="cov8" title="1">{

        // TODO: log the configuration on startup

        app := &amp;App{
                Config:       cfg,
                logger:       logger,
                repositories: repositories.NewRepositories(cl),
                Scheme:       scheme,
                RequestAuthN: reqAuthN,
                RequestAuthZ: reqAuthZ,
        }
        return app, nil
}</span>

// Routes returns the HTTP handler for the app
func (a *App) Routes() http.Handler <span class="cov0" title="0">{
        router := httprouter.New()

        router.NotFound = http.HandlerFunc(a.notFoundResponse)
        router.MethodNotAllowed = http.HandlerFunc(a.methodNotAllowedResponse)

        // healthcheck
        router.GET(HealthCheckPath, a.GetHealthcheckHandler)

        // namespaces
        router.GET(AllNamespacesPath, a.GetNamespacesHandler)

        // workspaces
        router.GET(AllWorkspacesPath, a.GetWorkspacesHandler)
        router.GET(WorkspacesByNamespacePath, a.GetWorkspacesHandler)
        router.GET(WorkspacesByNamePath, a.GetWorkspaceHandler)
        router.POST(WorkspacesByNamespacePath, a.CreateWorkspaceHandler)
        router.DELETE(WorkspacesByNamePath, a.DeleteWorkspaceHandler)

        // workspacekinds
        router.GET(AllWorkspaceKindsPath, a.GetWorkspaceKindsHandler)
        router.GET(WorkspaceKindsByNamePath, a.GetWorkspaceKindHandler)

        // swagger
        router.GET(SwaggerPath, a.GetSwaggerHandler)

        return a.recoverPanic(a.enableCORS(router))
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "fmt"
        "net/http"

        "k8s.io/apiserver/pkg/authorization/authorizer"

        "github.com/kubeflow/notebooks/workspaces/backend/internal/auth"
)

// requireAuth verifies that the request is authenticated and authorized to take the actions specified by the given policies.
// If this method returns false, the request has been handled and the caller should return immediately.
// If this method returns true, the request is authenticated and authorized to proceed.
// This method should only be called once per request.
func (a *App) requireAuth(w http.ResponseWriter, r *http.Request, policies []*auth.ResourcePolicy) bool <span class="cov8" title="1">{
        ctx := r.Context()

        // if auth is disabled, allow the request to proceed
        if a.Config.DisableAuth </span><span class="cov0" title="0">{
                return true
        }</span>

        // authenticate the request (extract user and groups from the request headers)
        <span class="cov8" title="1">res, ok, err := a.RequestAuthN.AuthenticateRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to authenticate request: %w", err)
                a.serverErrorResponse(w, r, err)
                return false
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                a.unauthorizedResponse(w, r)
                return false
        }</span>

        // for each policy, check if the user is authorized to take the requested action
        <span class="cov8" title="1">for _, policy := range policies </span><span class="cov8" title="1">{
                attributes := policy.AttributesFor(res.User)
                authorized, reason, err := a.RequestAuthZ.Authorize(ctx, attributes)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to authorize request for user %q: %w", res.User.GetName(), err)
                        a.serverErrorResponse(w, r, err)
                        return false
                }</span>

                <span class="cov8" title="1">if authorized != authorizer.DecisionAllow </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("authorization was denied for user %q", res.User.GetName())
                        if reason != "" </span><span class="cov0" title="0">{
                                msg = fmt.Sprintf("%s: %s", msg, reason)
                        }</span>
                        <span class="cov0" title="0">a.forbiddenResponse(w, r, msg)
                        return false</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "net/http"

        "github.com/julienschmidt/httprouter"

        _ "github.com/kubeflow/notebooks/workspaces/backend/internal/models/health_check"
)

// GetHealthcheckHandler returns the health status of the application.
//
//        @Summary                Returns the health status of the application
//        @Description        Provides a healthcheck response indicating the status of key services.
//        @Tags                        healthcheck
//        @Produce                application/json
//        @Success                200        {object}        health_check.HealthCheck        "Successful healthcheck response"
//        @Failure                500        {object}        ErrorEnvelope                                "Internal server error"
//        @Router                        /healthcheck [get]
func (a *App) GetHealthcheckHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) <span class="cov8" title="1">{

        healthCheck, err := a.repositories.HealthCheck.HealthCheck(Version)
        if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">err = a.WriteJSON(w, http.StatusOK, healthCheck, nil)
        if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "encoding/json"
        "fmt"
        "mime"
        "net/http"
        "strings"
)

// Envelope is the body of all requests and responses that contain data.
// NOTE: error responses use the ErrorEnvelope type
type Envelope[D any] struct {
        // TODO: make all declarations of Envelope use pointers for D

        Data D `json:"data"`
}

// WriteJSON writes a JSON response with the given status code, data, and headers.
func (a *App) WriteJSON(w http.ResponseWriter, status int, data any, headers http.Header) error <span class="cov8" title="1">{

        js, err := json.MarshalIndent(data, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">js = append(js, '\n')

        for key, value := range headers </span><span class="cov0" title="0">{
                w.Header()[key] = value
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _, err = w.Write(js)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DecodeJSON decodes the JSON request body into the given value.
func (a *App) DecodeJSON(r *http.Request, v any) error <span class="cov8" title="1">{
        decoder := json.NewDecoder(r.Body)
        decoder.DisallowUnknownFields()
        if err := decoder.Decode(v); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error decoding JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateContentType validates the Content-Type header of the request.
// If this method returns false, the request has been handled and the caller should return immediately.
// If this method returns true, the request has the correct Content-Type.
func (a *App) ValidateContentType(w http.ResponseWriter, r *http.Request, expectedMediaType string) bool <span class="cov8" title="1">{
        contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                a.unsupportedMediaTypeResponse(w, r, fmt.Errorf("Content-Type header is missing"))
                return false
        }</span>
        <span class="cov8" title="1">mediaType, _, err := mime.ParseMediaType(contentType)
        if err != nil </span><span class="cov0" title="0">{
                a.badRequestResponse(w, r, fmt.Errorf("error parsing Content-Type header: %w", err))
                return false
        }</span>
        <span class="cov8" title="1">if mediaType != expectedMediaType </span><span class="cov0" title="0">{
                a.unsupportedMediaTypeResponse(w, r, fmt.Errorf("unsupported media type: %s, expected: %s", mediaType, expectedMediaType))
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// LocationGetWorkspace returns the GET location (HTTP path) for a workspace resource.
func (a *App) LocationGetWorkspace(namespace, name string) string <span class="cov8" title="1">{
        path := strings.Replace(WorkspacesByNamePath, ":"+NamespacePathParam, namespace, 1)
        path = strings.Replace(path, ":"+ResourceNamePathParam, name, 1)
        return path
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import "net/http"

// LogError logs an error message with the request details.
func (a *App) LogError(r *http.Request, err error) <span class="cov0" title="0">{
        var (
                method = r.Method
                uri    = r.URL.RequestURI()
        )
        a.logger.Error(err.Error(), "method", method, "uri", uri)
}</span>

// LogWarn logs a warning message with the request details.
func (a *App) LogWarn(r *http.Request, message string) <span class="cov0" title="0">{
        var (
                method = r.Method
                uri    = r.URL.RequestURI()
        )
        a.logger.Warn(message, "method", method, "uri", uri)
}</span>

// LogInfo logs an info message with the request details.
func (a *App) LogInfo(r *http.Request, message string) <span class="cov0" title="0">{
        var (
                method = r.Method
                uri    = r.URL.RequestURI()
        )
        a.logger.Info(message, "method", method, "uri", uri)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "fmt"
        "net/http"
)

func (a *App) recoverPanic(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                w.Header().Set("Connection", "close")
                                a.serverErrorResponse(w, r, fmt.Errorf("%s", err))
                        }</span>
                }()

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func (a *App) enableCORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO(ederign) restrict CORS to a much smaller set of trusted origins.
                // TODO(ederign) deal with preflight requests
                w.Header().Set("Access-Control-Allow-Origin", "*")

                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "net/http"

        "github.com/julienschmidt/httprouter"
        corev1 "k8s.io/api/core/v1"

        "github.com/kubeflow/notebooks/workspaces/backend/internal/auth"
        models "github.com/kubeflow/notebooks/workspaces/backend/internal/models/namespaces"
)

type NamespaceListEnvelope Envelope[[]models.Namespace]

// GetNamespacesHandler returns a list of all namespaces.
//
//        @Summary                Returns a list of all namespaces
//        @Description        Provides a list of all namespaces that the user has access to
//        @Tags                        namespaces
//        @Produce                application/json
//        @Success                200        {object}        NamespaceListEnvelope        "Successful namespaces response"
//        @Failure                401        {object}        ErrorEnvelope                        "Unauthorized"
//        @Failure                403        {object}        ErrorEnvelope                        "Forbidden"
//        @Failure                500        {object}        ErrorEnvelope                        "Internal server error"
//        @Router                        /namespaces [get]
func (a *App) GetNamespacesHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) <span class="cov8" title="1">{

        // =========================== AUTH ===========================
        authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbList,
                        &amp;corev1.Namespace{},
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">namespaces, err := a.repositories.Namespace.GetNamespaces(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">responseEnvelope := &amp;NamespaceListEnvelope{Data: namespaces}
        a.dataResponse(w, r, responseEnvelope)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "fmt"
        "net/http"
        "strconv"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

const (
        errMsgPathParamsInvalid    = "path parameters were invalid"
        errMsgRequestBodyInvalid   = "request body was invalid"
        errMsgKubernetesValidation = "kubernetes validation error (note: .cause.validation_errors[] correspond to the internal k8s object, not the request body)"
)

// ErrorEnvelope is the body of all error responses.
type ErrorEnvelope struct {
        Error *HTTPError `json:"error"`
}

type HTTPError struct {
        StatusCode int `json:"-"`
        ErrorResponse
}

type ErrorResponse struct {
        Code    string      `json:"code"`
        Message string      `json:"message"`
        Cause   *ErrorCause `json:"cause,omitempty"`
}

type ErrorCause struct {
        ValidationErrors []ValidationError `json:"validation_errors,omitempty"`
}

type ValidationError struct {
        Type    field.ErrorType `json:"type"`
        Field   string          `json:"field"`
        Message string          `json:"message"`
}

// errorResponse writes an error response to the client.
func (a *App) errorResponse(w http.ResponseWriter, r *http.Request, httpError *HTTPError) <span class="cov8" title="1">{
        env := ErrorEnvelope{Error: httpError}

        err := a.WriteJSON(w, httpError.StatusCode, env, nil)
        if err != nil </span><span class="cov0" title="0">{
                a.LogError(r, err)
                w.WriteHeader(httpError.StatusCode)
        }</span>
}

// HTTP: 500
func (a *App) serverErrorResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        a.LogError(r, err)

        httpError := &amp;HTTPError{
                StatusCode: http.StatusInternalServerError,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusInternalServerError),
                        Message: "the server encountered a problem and could not process your request",
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 400
func (a *App) badRequestResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        httpError := &amp;HTTPError{
                StatusCode: http.StatusBadRequest,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusBadRequest),
                        Message: err.Error(),
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 401
func (a *App) unauthorizedResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        httpError := &amp;HTTPError{
                StatusCode: http.StatusUnauthorized,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusUnauthorized),
                        Message: "authentication is required to access this resource",
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 403
func (a *App) forbiddenResponse(w http.ResponseWriter, r *http.Request, msg string) <span class="cov0" title="0">{
        a.LogWarn(r, msg)

        httpError := &amp;HTTPError{
                StatusCode: http.StatusForbidden,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusForbidden),
                        Message: "you are not authorized to access this resource",
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 404
func (a *App) notFoundResponse(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        httpError := &amp;HTTPError{
                StatusCode: http.StatusNotFound,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusNotFound),
                        Message: "the requested resource could not be found",
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 405
func (a *App) methodNotAllowedResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        httpError := &amp;HTTPError{
                StatusCode: http.StatusMethodNotAllowed,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusMethodNotAllowed),
                        Message: fmt.Sprintf("the %s method is not supported for this resource", r.Method),
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 409
func (a *App) conflictResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        httpError := &amp;HTTPError{
                StatusCode: http.StatusConflict,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusConflict),
                        Message: err.Error(),
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP:415
func (a *App) unsupportedMediaTypeResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        httpError := &amp;HTTPError{
                StatusCode: http.StatusUnsupportedMediaType,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusUnsupportedMediaType),
                        Message: err.Error(),
                },
        }
        a.errorResponse(w, r, httpError)
}</span>

// HTTP: 422
func (a *App) failedValidationResponse(w http.ResponseWriter, r *http.Request, msg string, errs field.ErrorList, k8sCauses []metav1.StatusCause) <span class="cov0" title="0">{
        valErrs := make([]ValidationError, len(errs)+len(k8sCauses))

        // convert field errors to validation errors
        for i, err := range errs </span><span class="cov0" title="0">{
                valErrs[i] = ValidationError{
                        Type:    err.Type,
                        Field:   err.Field,
                        Message: err.ErrorBody(),
                }
        }</span>

        // convert k8s causes to validation errors
        <span class="cov0" title="0">for i, cause := range k8sCauses </span><span class="cov0" title="0">{
                valErrs[i+len(errs)] = ValidationError{
                        Type:    field.ErrorType(cause.Type),
                        Field:   cause.Field,
                        Message: cause.Message,
                }
        }</span>

        <span class="cov0" title="0">httpError := &amp;HTTPError{
                StatusCode: http.StatusUnprocessableEntity,
                ErrorResponse: ErrorResponse{
                        Code:    strconv.Itoa(http.StatusUnprocessableEntity),
                        Message: msg,
                        Cause: &amp;ErrorCause{
                                ValidationErrors: valErrs,
                        },
                },
        }
        a.errorResponse(w, r, httpError)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import "net/http"

// HTTP: 200
func (a *App) dataResponse(w http.ResponseWriter, r *http.Request, body any) <span class="cov8" title="1">{
        err := a.WriteJSON(w, http.StatusOK, body, nil)
        if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
        }</span>
}

// HTTP: 201
func (a *App) createdResponse(w http.ResponseWriter, r *http.Request, body any, location string) <span class="cov8" title="1">{
        w.Header().Set("Location", location)
        err := a.WriteJSON(w, http.StatusCreated, body, nil)
        if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
        }</span>
}

// HTTP: 204
func (a *App) deletedResponse(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.WriteHeader(http.StatusNoContent)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "net/http"

        "github.com/julienschmidt/httprouter"
        httpSwagger "github.com/swaggo/http-swagger/v2"
)

func (a *App) GetSwaggerHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) <span class="cov0" title="0">{
        httpSwagger.Handler(
                httpSwagger.URL(SwaggerDocPath),
                httpSwagger.DeepLinking(true),
                httpSwagger.DocExpansion("list"),
                httpSwagger.DomID("swagger-ui"),
        ).ServeHTTP(w, r)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "errors"
        "net/http"

        "github.com/julienschmidt/httprouter"
        kubefloworgv1beta1 "github.com/kubeflow/notebooks/workspaces/controller/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/validation/field"

        "github.com/kubeflow/notebooks/workspaces/backend/internal/auth"
        "github.com/kubeflow/notebooks/workspaces/backend/internal/helper"
        models "github.com/kubeflow/notebooks/workspaces/backend/internal/models/workspacekinds"
        repository "github.com/kubeflow/notebooks/workspaces/backend/internal/repositories/workspacekinds"
)

type WorkspaceKindListEnvelope Envelope[[]models.WorkspaceKind]

type WorkspaceKindEnvelope Envelope[models.WorkspaceKind]

// GetWorkspaceKindHandler retrieves a specific workspace kind by name.
//
//        @Summary                Get workspace kind
//        @Description        Returns details of a specific workspace kind identified by its name. Workspace kinds define the available types of workspaces that can be created.
//        @Tags                        workspacekinds
//        @Accept                        json
//        @Produce                json
//        @Param                        name        path                string                                        true        "Name of the workspace kind"        example(jupyterlab)
//        @Success                200                {object}        WorkspaceKindEnvelope        "Successful operation. Returns the requested workspace kind details."
//        @Failure                400                {object}        ErrorEnvelope                        "Bad Request. Invalid workspace kind name format."
//        @Failure                401                {object}        ErrorEnvelope                        "Unauthorized. Authentication is required."
//        @Failure                403                {object}        ErrorEnvelope                        "Forbidden. User does not have permission to access the workspace kind."
//        @Failure                404                {object}        ErrorEnvelope                        "Not Found. Workspace kind does not exist."
//        @Failure                500                {object}        ErrorEnvelope                        "Internal server error. An unexpected error occurred on the server."
//        @Router                        /workspacekinds/{name} [get]
//        @Security                ApiKeyAuth
func (a *App) GetWorkspaceKindHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) <span class="cov8" title="1">{
        name := ps.ByName(ResourceNamePathParam)

        // validate path parameters
        var valErrs field.ErrorList
        valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(ResourceNamePathParam), name)...)
        if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                a.failedValidationResponse(w, r, errMsgPathParamsInvalid, valErrs, nil)
                return
        }</span>

        // =========================== AUTH ===========================
        <span class="cov8" title="1">authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbGet,
                        &amp;kubefloworgv1beta1.WorkspaceKind{
                                ObjectMeta: metav1.ObjectMeta{Name: name},
                        },
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">workspaceKind, err := a.repositories.WorkspaceKind.GetWorkspaceKind(r.Context(), name)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrWorkspaceKindNotFound) </span><span class="cov8" title="1">{
                        a.notFoundResponse(w, r)
                        return
                }</span>
                <span class="cov0" title="0">a.serverErrorResponse(w, r, err)
                return</span>
        }

        <span class="cov8" title="1">responseEnvelope := &amp;WorkspaceKindEnvelope{Data: workspaceKind}
        a.dataResponse(w, r, responseEnvelope)</span>
}

// GetWorkspaceKindsHandler returns a list of all available workspace kinds.
//
//        @Summary                List workspace kinds
//        @Description        Returns a list of all available workspace kinds. Workspace kinds define the different types of workspaces that can be created in the system.
//        @Tags                        workspacekinds
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        WorkspaceKindListEnvelope        "Successful operation. Returns a list of all available workspace kinds."
//        @Failure                401        {object}        ErrorEnvelope                                "Unauthorized. Authentication is required."
//        @Failure                403        {object}        ErrorEnvelope                                "Forbidden. User does not have permission to list workspace kinds."
//        @Failure                500        {object}        ErrorEnvelope                                "Internal server error. An unexpected error occurred on the server."
//        @Router                        /workspacekinds [get]
//        @Security                ApiKeyAuth
func (a *App) GetWorkspaceKindsHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) <span class="cov8" title="1">{
        // =========================== AUTH ===========================
        authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbList,
                        &amp;kubefloworgv1beta1.WorkspaceKind{},
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">workspaceKinds, err := a.repositories.WorkspaceKind.GetWorkspaceKinds(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">responseEnvelope := &amp;WorkspaceKindListEnvelope{Data: workspaceKinds}
        a.dataResponse(w, r, responseEnvelope)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package api

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/julienschmidt/httprouter"
        kubefloworgv1beta1 "github.com/kubeflow/notebooks/workspaces/controller/api/v1beta1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/validation/field"

        "github.com/kubeflow/notebooks/workspaces/backend/internal/auth"
        "github.com/kubeflow/notebooks/workspaces/backend/internal/helper"
        models "github.com/kubeflow/notebooks/workspaces/backend/internal/models/workspaces"
        repository "github.com/kubeflow/notebooks/workspaces/backend/internal/repositories/workspaces"
)

type WorkspaceCreateEnvelope Envelope[*models.WorkspaceCreate]

type WorkspaceListEnvelope Envelope[[]models.Workspace]

type WorkspaceEnvelope Envelope[models.Workspace]

// GetWorkspaceHandler retrieves a specific workspace by namespace and name.
//
//        @Summary                Get workspace
//        @Description        Returns details of a specific workspace identified by namespace and workspace name.
//        @Tags                        workspaces
//        @Accept                        json
//        @Produce                json
//        @Param                        namespace                path                string                                true        "Namespace of the workspace"        example(kubeflow-user-example-com)
//        @Param                        workspace_name        path                string                                true        "Name of the workspace"                        example(my-workspace)
//        @Success                200                                {object}        WorkspaceEnvelope        "Successful operation. Returns the requested workspace details."
//        @Failure                400                                {object}        ErrorEnvelope                "Bad Request. Invalid namespace or workspace name format."
//        @Failure                401                                {object}        ErrorEnvelope                "Unauthorized. Authentication is required."
//        @Failure                403                                {object}        ErrorEnvelope                "Forbidden. User does not have permission to access the workspace."
//        @Failure                404                                {object}        ErrorEnvelope                "Not Found. Workspace does not exist."
//        @Failure                500                                {object}        ErrorEnvelope                "Internal server error. An unexpected error occurred on the server."
//        @Router                        /workspaces/{namespace}/{workspace_name} [get]
//        @Security                ApiKeyAuth
func (a *App) GetWorkspaceHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) <span class="cov8" title="1">{
        namespace := ps.ByName(NamespacePathParam)
        workspaceName := ps.ByName(ResourceNamePathParam)

        // validate path parameters
        var valErrs field.ErrorList
        valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(NamespacePathParam), namespace)...)
        valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(ResourceNamePathParam), workspaceName)...)
        if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                a.failedValidationResponse(w, r, errMsgPathParamsInvalid, valErrs, nil)
                return
        }</span>

        // =========================== AUTH ===========================
        <span class="cov8" title="1">authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbGet,
                        &amp;kubefloworgv1beta1.Workspace{
                                ObjectMeta: metav1.ObjectMeta{
                                        Namespace: namespace,
                                        Name:      workspaceName,
                                },
                        },
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">workspace, err := a.repositories.Workspace.GetWorkspace(r.Context(), namespace, workspaceName)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrWorkspaceNotFound) </span><span class="cov8" title="1">{
                        a.notFoundResponse(w, r)
                        return
                }</span>
                <span class="cov0" title="0">a.serverErrorResponse(w, r, err)
                return</span>
        }

        <span class="cov8" title="1">responseEnvelope := &amp;WorkspaceEnvelope{Data: workspace}
        a.dataResponse(w, r, responseEnvelope)</span>
}

// GetWorkspacesHandler returns a list of workspaces.
//
//        @Summary                List workspaces
//        @Description        Returns a list of workspaces. The endpoint supports two modes:
//        @Description        1. List all workspaces across all namespaces (when no namespace is provided)
//        @Description        2. List workspaces in a specific namespace (when namespace is provided)
//        @Tags                        workspaces
//        @Accept                        json
//        @Produce                json
//        @Param                        namespace        path                string                                        false        "Namespace to filter workspaces. If not provided, returns all workspaces across all namespaces."        example(kubeflow-user-example-com)
//        @Success                200                        {object}        WorkspaceListEnvelope        "Successful operation. Returns a list of workspaces."
//        @Failure                400                        {object}        ErrorEnvelope                        "Bad Request. Invalid namespace format."
//        @Failure                401                        {object}        ErrorEnvelope                        "Unauthorized. Authentication is required."
//        @Failure                403                        {object}        ErrorEnvelope                        "Forbidden. User does not have permission to list workspaces."
//        @Failure                500                        {object}        ErrorEnvelope                        "Internal server error. An unexpected error occurred on the server."
//        @Router                        /workspaces [get]
//        @Router                        /workspaces/{namespace} [get]
//        @Security                ApiKeyAuth
func (a *App) GetWorkspacesHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) <span class="cov8" title="1">{
        namespace := ps.ByName(NamespacePathParam)

        // validate path parameters
        // NOTE: namespace is optional, if not provided, we list all workspaces across all namespaces
        var valErrs field.ErrorList
        if namespace != "" </span><span class="cov8" title="1">{
                valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(NamespacePathParam), namespace)...)
        }</span>
        <span class="cov8" title="1">if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                a.failedValidationResponse(w, r, errMsgPathParamsInvalid, valErrs, nil)
                return
        }</span>

        // =========================== AUTH ===========================
        <span class="cov8" title="1">authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbList,
                        &amp;kubefloworgv1beta1.Workspace{
                                ObjectMeta: metav1.ObjectMeta{
                                        Namespace: namespace,
                                },
                        },
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">var workspaces []models.Workspace
        var err error
        if namespace == "" </span><span class="cov8" title="1">{
                workspaces, err = a.repositories.Workspace.GetAllWorkspaces(r.Context())
        }</span> else<span class="cov8" title="1"> {
                workspaces, err = a.repositories.Workspace.GetWorkspaces(r.Context(), namespace)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                a.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">responseEnvelope := &amp;WorkspaceListEnvelope{Data: workspaces}
        a.dataResponse(w, r, responseEnvelope)</span>
}

// CreateWorkspaceHandler creates a new workspace in the specified namespace.
//
//        @Summary                Create workspace
//        @Description        Creates a new workspace in the specified namespace.
//        @Tags                        workspaces
//        @Accept                        json
//        @Produce                json
//        @Param                        namespace        path                string                                        true        "Namespace for the workspace"        example(kubeflow-user-example-com)
//        @Param                        body                body                WorkspaceCreateEnvelope        true        "Workspace creation configuration"
//        @Success                201                        {object}        WorkspaceEnvelope                "Workspace created successfully"
//        @Failure                400                        {object}        ErrorEnvelope                        "Bad Request. Invalid request body or namespace format."
//        @Failure                401                        {object}        ErrorEnvelope                        "Unauthorized. Authentication is required."
//        @Failure                403                        {object}        ErrorEnvelope                        "Forbidden. User does not have permission to create workspace."
//        @Failure                409                        {object}        ErrorEnvelope                        "Conflict. Workspace with the same name already exists."
//        @Failure                500                        {object}        ErrorEnvelope                        "Internal server error. An unexpected error occurred on the server."
//        @Router                        /workspaces/{namespace} [post]
//        @Security                ApiKeyAuth
func (a *App) CreateWorkspaceHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) <span class="cov8" title="1">{
        namespace := ps.ByName(NamespacePathParam)

        // validate path parameters
        var valErrs field.ErrorList
        valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(NamespacePathParam), namespace)...)
        if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                a.failedValidationResponse(w, r, errMsgPathParamsInvalid, valErrs, nil)
                return
        }</span>

        // validate the Content-Type header
        <span class="cov8" title="1">if success := a.ValidateContentType(w, r, "application/json"); !success </span><span class="cov0" title="0">{
                return
        }</span>

        // decode the request body
        <span class="cov8" title="1">bodyEnvelope := &amp;WorkspaceCreateEnvelope{}
        err := a.DecodeJSON(r, bodyEnvelope)
        if err != nil </span><span class="cov0" title="0">{
                a.badRequestResponse(w, r, fmt.Errorf("error decoding request body: %w", err))
                return
        }</span>

        // validate the request body
        <span class="cov8" title="1">dataPath := field.NewPath("data")
        if bodyEnvelope.Data == nil </span><span class="cov0" title="0">{
                valErrs = field.ErrorList{field.Required(dataPath, "data is required")}
                a.failedValidationResponse(w, r, errMsgRequestBodyInvalid, valErrs, nil)
                return
        }</span>
        <span class="cov8" title="1">valErrs = bodyEnvelope.Data.Validate(dataPath)
        if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                a.failedValidationResponse(w, r, errMsgRequestBodyInvalid, valErrs, nil)
                return
        }</span>

        <span class="cov8" title="1">workspaceCreate := bodyEnvelope.Data

        // =========================== AUTH ===========================
        authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbCreate,
                        &amp;kubefloworgv1beta1.Workspace{
                                ObjectMeta: metav1.ObjectMeta{
                                        Namespace: namespace,
                                        Name:      workspaceCreate.Name,
                                },
                        },
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">createdWorkspace, err := a.repositories.Workspace.CreateWorkspace(r.Context(), workspaceCreate, namespace)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrWorkspaceAlreadyExists) </span><span class="cov0" title="0">{
                        a.conflictResponse(w, r, err)
                        return
                }</span>
                <span class="cov0" title="0">if apierrors.IsInvalid(err) </span><span class="cov0" title="0">{
                        causes := helper.StatusCausesFromAPIStatus(err)
                        a.failedValidationResponse(w, r, errMsgKubernetesValidation, nil, causes)
                        return
                }</span>
                <span class="cov0" title="0">a.serverErrorResponse(w, r, fmt.Errorf("error creating workspace: %w", err))
                return</span>
        }

        // calculate the GET location for the created workspace (for the Location header)
        <span class="cov8" title="1">location := a.LocationGetWorkspace(namespace, createdWorkspace.Name)

        responseEnvelope := &amp;WorkspaceCreateEnvelope{Data: createdWorkspace}
        a.createdResponse(w, r, responseEnvelope, location)</span>
}

// DeleteWorkspaceHandler deletes a specific workspace by namespace and name.
//
//        @Summary                Delete workspace
//        @Description        Deletes a specific workspace identified by namespace and workspace name.
//        @Tags                        workspaces
//        @Accept                        json
//        @Produce                json
//        @Param                        namespace                path                string                        true        "Namespace of the workspace"        example(kubeflow-user-example-com)
//        @Param                        workspace_name        path                string                        true        "Name of the workspace"                        example(my-workspace)
//        @Success                204                                {object}        nil                                "Workspace deleted successfully"
//        @Failure                400                                {object}        ErrorEnvelope        "Bad Request. Invalid namespace or workspace name format."
//        @Failure                401                                {object}        ErrorEnvelope        "Unauthorized. Authentication is required."
//        @Failure                403                                {object}        ErrorEnvelope        "Forbidden. User does not have permission to delete the workspace."
//        @Failure                404                                {object}        ErrorEnvelope        "Not Found. Workspace does not exist."
//        @Failure                500                                {object}        ErrorEnvelope        "Internal server error. An unexpected error occurred on the server."
//        @Router                        /workspaces/{namespace}/{workspace_name} [delete]
//        @Security                ApiKeyAuth
func (a *App) DeleteWorkspaceHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) <span class="cov8" title="1">{
        namespace := ps.ByName(NamespacePathParam)
        workspaceName := ps.ByName(ResourceNamePathParam)

        // validate path parameters
        var valErrs field.ErrorList
        valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(NamespacePathParam), namespace)...)
        valErrs = append(valErrs, helper.ValidateFieldIsDNS1123Subdomain(field.NewPath(ResourceNamePathParam), workspaceName)...)
        if len(valErrs) &gt; 0 </span><span class="cov0" title="0">{
                a.failedValidationResponse(w, r, errMsgPathParamsInvalid, valErrs, nil)
                return
        }</span>

        // =========================== AUTH ===========================
        <span class="cov8" title="1">authPolicies := []*auth.ResourcePolicy{
                auth.NewResourcePolicy(
                        auth.ResourceVerbDelete,
                        &amp;kubefloworgv1beta1.Workspace{
                                ObjectMeta: metav1.ObjectMeta{
                                        Namespace: namespace,
                                        Name:      workspaceName,
                                },
                        },
                ),
        }
        if success := a.requireAuth(w, r, authPolicies); !success </span><span class="cov0" title="0">{
                return
        }</span>
        // ============================================================

        <span class="cov8" title="1">err := a.repositories.Workspace.DeleteWorkspace(r.Context(), namespace, workspaceName)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrWorkspaceNotFound) </span><span class="cov0" title="0">{
                        a.notFoundResponse(w, r)
                        return
                }</span>
                <span class="cov0" title="0">a.serverErrorResponse(w, r, err)
                return</span>
        }

        <span class="cov8" title="1">a.deletedResponse(w, r)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
